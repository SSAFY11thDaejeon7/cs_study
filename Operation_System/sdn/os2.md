### 운영체제의 역할

    
운영체제는 사용자가 시스템을 편리하게 사용할 수 있도록 유저 인터페이스(user Interface)를 제공해줍니다. 그리고 주워진 자원들을 잘 활용해서 서비스의 효율성을 높여줍니다. 프로세스와 스레를 관리하는 역할도 운영체제가 합니다. 불법적인 요소로부터 시스템을 보호하는 역할도 있습니다.

<br>

### Q. System call (Interface) 이란?

System Call (Interface)는 커널이 제공하는 기능들 중에서 사용자가 사용할 수 있는 기능들을 모아놓은 것입니다. 
    
사용자가 커널을 직접 접근해 조작해버리면, os가 하드웨어를 제어하는데 문제가 발생할 수 있습니다. 그래서 직접 접근이 아닌 os에게 요청을 해야합니다. 이러한 요청을 하는 통로가 System call Interface입니다.

<br>

### Q. 운영체제를 구분하는법

    
동시 사용자 수와 동시 실행 프로세스 수로 나누게 됩니다.
    
동시 사용자 수로 나누면 단일 사용자와 다중 사용자로 나눌 수 있습니다.
    
단일 사용자 (Single-user system)는 한명의 사용자만 시스템 사용이 가능합니다. 
    
한명의 사용자가 모든 시스템 자원을 독점해 사용하기 때문에 상대적으로 자원 관리 및 시스템 보호 방식이 간단 합니다.
    
개인용 장비(pc, moblie) 등에 사용
    
ex) Windows 7/10, android, MS-DOS 등

<br>
    
다중 사용자 (Multi-user system)는 동시에 여러 사용자들이 시스템 사용이 가능합니다.
    
여러 사용자들이 사용해 시스템 자원들에 대한 소유 권한 관리가 필요하고, Multi-tasking 기능이 필요합니다. 그래서 os의 기능 및 구조가 상대적으로 복잡합니다.
    
서버, 클러스터(cluster) 장비 등에 사용
    
ex) Unix, Linux, Windows server 등

<br>
    
실행 프로세스 수로 나누면 단일 작업과 다중 작업으로 나눌 수 있습니다.
    
단일 작업(Single-tasking system)은 시스템 내에 하나의 작업(프로세스)만 수행할 수 있습니다.
    
ex) MS-DOS
    
다중 작업(Multi-tasking system)은 동시에 여러 작업(프로세스)을 수행할 수 있습니다.
    
그래서 작업들 사이의 동시 수행, 동기화 등을 관리해줘야 합니다.
    
운영체제의 기능 및 구조가 복잡해집니다.
    
ex) Unix/Linux, Windows 
  
<br>

### Multi-tasking이 필요한 이유
    
하나의 서버에서 여러 사용자들이 이용하므로 여러 개의 프로그램을 돌릴 수 있어야 합니다. 
    
<br>

### Q. batch system

    
운영체제가 없던 시절 사용자가 일일이 프로세서의 동작 방식 등 컴퓨터에 필요한 작업을 사용자가 직접 기계어로 프로그램을 작성해야 했습니다.
    
그래서 각 작업에 대해 준비 시간이 소요 됐습니다. 이런 준비 시간(컴퓨터가 쉬는 시간을 줄이는 기 위해 나온 것이 batch systems  입니다.
    
batch systems은 사용자의 요청 작업을 일정 시간 모아둔 것을 한번에 실행하는 것입니다. 모아둔 것을 한번에 실행을 해 준비 시간을 줄였습니다.
    
batch system은 시스템 지향적(System-oriented)입니다. 자원을 모아뒀다가 시스템 준비 시간을 한번만 가지고 많이 처리를 해 시스템을 더 효율적으로 사용할 수 있습니다. 이러한 모아둔 자원들은 많은 사용자가 시스템 자원을 공유할 수 있으며, 시스템 자원의 처리 효율(throughput)이 향상 됩니다.
    
하지만 시스템 자원을 모아서 실행하기 때문에 대기 시간이 있어 생산성(productivity)이 저하 됩니다. 그리고 작업 제출에서 결과 출력까지 약 6시간 정도로 응답 시간이 깁니다.
    
 <br>   

### Q. 시분할 시스템(Time Sharing Systems)

    
시분할 시스템은 시간을 나눠서 여러 사용자가 자원을 동시에 사용할 수 있도록 해주는 시스템 입니다. 자원을 동시에 사용하게 됨으로 os가 파일 시스템 및 가상 메모리 관리를 하기 시작했습니다.
    
이전에는 프로그램이 종료 후 다음 프로그램을 실행할 수 있었습니다.
    
<br>

사용자 지향
    
대화형(conversational, interactive) 시스템
단말기(CRT terminal) 사용
    
<br>
    
### 시분할 시스템의 장단점
    
반응을 일정 시간안에 주어서 응답 시간이 단축(약 5초) 되었습니다. 
    
내가 작업을 하다가 반응을 받을 수 있어 사용자 측면에서 생산성이 향상 됐습니다.
    
시분할 시스템 덕분에 쉬지 않고 여러개 프로세스를 동작할 수 있게 되어 프로세서의 유휴 시간이 감소 했습니다.
    
그러나 단말기를 통해 접속을 해서, 통신 비용이 증가 했습니다. 통신을 하면서 보안 문제도 발생했습니다. 그리고 동시 사용자 수가 많으면 시스템 부하가 커지고 시스템이 느려질 수 있습니다.
그래서 개인 사용자 체감 속도가 저하 됐습니다.
    
<br>

### Q. Personal Computing


Personal Computing은 개인의 시스템 전체를 독점해서 사용합니다.
    
이전에는 cpu를 쉬지 않고 시스템을 계속 사용하도록 집중했다면, 개인 시스템이 되면서 cpu의 활용률이 고려 대상이 아니게 됐습니다. 사용자가 편하게 사용할 수 있는 점을 고려하게 됐었습니다. 개인 시스템이라서 빠른 응답 시간을 갖지만 개인이 사용하는데 높은 비용을 쓰지 않으므로  성능이 낮습니다.

<br>
    
### Parallel Processing System(개인 시스템의 성능이 낮은 것을 해결 방법)
    
병렬 처리 시스템은 cpu는 여러개 두고 공유 자원들을 이용해 사용하는 시스템(Tightly-coupled system)이다. 병렬 처리 시스템은 성능 향상에 효과가 있고 cpu가 여러개 있어 하나가 고장이 나도 대신 동작 해줄 cpu가 있어 신뢰성도 향상 합니다.
    
단, cpu들(프로세서) 간 관계 및 역할 관리가 필요합니다. 
    
위의 방법은 기능을 확장하는데 물리적, 시스템적 제약이 있습니다.
    
그래서 나온 컴퓨터를 여러대 붙이는 Distributed Processing Systems 방식이 있습니다.
    
<br>

### Q. Distributed Processing Systems

    
분산 처리 시스템은 네트워크를 기반으로 구축된 병렬 처리 시스템 입니다. (Loosely-coupled system) 연결되어 있는 컴퓨터들(노드)은 자기만의 os를 가지고 있는데, 이것을 관리해주는 분산 운영체제를 통해 하나의 프로그램, 자원처럼 사용할 수 있습니다. (은폐성, transparency)
    
ex) Cluster system, client-server system, P2P 
    
분산 처리 시스템은 자원 공유를 통한 높은 성능 얻을 수 있습니다. 병렬 처리 시스템을 사용하면서 높은 신뢰성과 높은 확장성을 가집니다. 하지만 구축 및 관리가 어렵습니다.
    
    
<br>

### Q. Real-time Systems

    
실시간 시스템은 작업 처리에 제한 시간을 갖는 시스템입니다. 제한 시간 내에 서비스를 제공하는 것이 자원 활용 효율보다 중요합니다. 
    
hard real-time task: 시간 제약을 지키지 못하는 경우 시스템에 치명적 영향을 발생합니다.
    
ex) 발전소 제어, 무기 제어 등
    
soft real-time task: 처리 못해도 큰 문제가 발생하지 않습니다.
    
ex) 동영상 재생 등
    
<br>

### Q. 운영체제의 구조

    
운영체제의 구조에는 커널과 유틸리티로 구분합니다. 
    
커널은 os의 핵심 부분입니다. 커널은 프로세서나, 메모리 관리와 같은 시스템 관리를 하는 기능들을 모아둔 것 입니다. 이러한 기능들은 계속 관리를 하기 때문에 커널은 메모리에 상주하고 있습니다. 
    
유틸리티는 UI와 같은 자주 사용하지 않는 프로그램을 말합니다. 가끔 사용을 해 메모리에 항상  올라가 있지 않습니다.

    <br>
    
### 단일 구조
    
커널에 하나에 많은 기능들을 포함하고 있습니다.그래서 커널 내 모듈간 직접 통신이 가능해, 효율적인 자원 관리가 가능합니다. 하지만 커널이 거대화해지면서 오류와 버그, 추가 기능 구현 등 유지보수가 어렵습니다. 또한 동일 메모리에 모든 기능이 있어, 한 모듈의 문제가 전체 시스템에 영향을 줍니다. (악성코드)
    
그래서 이러한 구조를 기능별로 나누어 설계를 한게 계층 구조 입니다.
    
기능별로 따로 만들어, 각각의 기능에만 집중할 수 있습니다. 그래서 계층간 검증 및 수정이 용의하고 설계 및 구현이 단순화 돼 유지보수가 쉬워졌습니다. 하지만 계층이 있으므로, 원하는 기능을 수행하기 위해 여러 계층을 거쳐야 할 수도 있어 단일 구조에 비해 성능이 낮습니다.

<br>
    
### 마이크로 커널 구조
    
커널의 크기를 최소화한 것, 필수 기능만 포함한 것 입니다. 기타 기능은 사용자 영역에서 수행합니다.
    
<br>

### Q. 운영체제의 기능

    - 프로세스 관리
    - 프로세서 관리
    - 메모리 관리
    - 파일 관리
    - 입출력 관리
    - 보조 기억 장치 및 기타 주변장치 관리

<br>

### 프로세스 관리
    
프로세스는 커널에 등록된 실행 단위 입니다. 사용자 요청을 수행하는 주체 입니다.

<br>
    
### os의 프로세스 관리 기능
    
- 생성/삭제, 상태관리
- 자원 할당
- 프로세스 간 통신 및 동기화
 - 교착상태 해결
    
 ### 프로세스 정보 관리
    
 - PCB(Process Control Block)
    
### 프로세서 관리
    
    - 중앙 처리 장치(cpu)
        - 프로그램을 실행하는 핵심 자원
    - 프로세스 스케줄링
        - 시스템 내의 프로세스 처리 순서 결정
    - 프로세서 할당 관리
        - 프로세스들에 대한 프로세서 할당
            - 한번에 하나의 프로세스만 사용 가능
    
 ### 메모리 관리
    
    - 주기억장치
        - 작업을 위한 프로그램 및 데이터를 올려 놓는 공간
    - multi-user, muti-tacking 시스템
    - 프로세스에 대한 메모리 할당 및 회수
    - 메모리 여유 공간 관리
    - 각 프로세스의 할당 메모리 영역 접근 보호
    
### 메모리 할당 방법
    
    - 전체 적재
        - 장점: 구현이 간단
        - 단점: 제한적 공간
    - 일부 적재
        - 프로그램 및 데이터의 일부만 적재
        - 장점: 메모리의 효율적 활용
        - 단점: 보조기억 장치 접근 필요

 ### 파일 관리
    
    파일: 논리적 데이터 저장 단위
    
    사용자 및 시스템의 파일 관리
    
    디렉토리 구조 지원
    
    파일 관리 기능
    
    - 파일 및 디렉토리 생성/ 삭제
    - 파일 접근 및 조작
    - 파일을 물리적 저장 공간으로 매핑
    - 백업 등
    
 ### 입출력 관리
    
    - 입출력 과정은 os를 반드시 거쳐야한다.
