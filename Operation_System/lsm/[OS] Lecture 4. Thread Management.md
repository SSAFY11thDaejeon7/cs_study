# 1. Thread의 정의

### 프로세스와 스레드

- 프로세스: **자원**을 할당받고 **제어**하여 원하는 작업을 수행하는 것

### 스레드란?

- <Resource>: 코드, 전역 데이터, 힙으로 구성
- <Thread>: 제어 정보/스택 포인터/지역 데이터/스택을 가지고 있음
    - 하나의 프로세스 내에 여러 개 존재한다.
- Light Weight Process (LWP: 가벼운 프로세스 / 프로세스의 제어 부분만 가지고 있음)
- 프로세서 (e.g CPU) 활용의 기본 단위
- 구성 요소
    - Thread ID
    - Register set(PC, SP 등)
    - Stack (i.e. local data)
- 제어 요소 외 코드, 데이터 및 **자원들은 프로세스 내 다른 스레드들과 공유**
- 전통적 프로세스 = 단일 스레드 프로세스
<img width="898" alt="프로세스와 자원" src="https://github.com/SSAFY11thDaejeon7/cs_study/assets/110437548/8f2e9337-5d68-4534-9800-cbc60934bbd9">


### 스레드의 메모리 공간
<img width="980" alt="프로세스의 메모리 공간" src="https://github.com/SSAFY11thDaejeon7/cs_study/assets/110437548/32b2db79-7aaa-49a8-abc1-a16ff57ffc6b">

### 스레드의 장점

- 사용자 응답성(Responsiveness)
    - 일부 스레드의 처리가 지연되어도, 다른 스레드는 작업을 계속 처리할 수 있음
- 자원 공유(Resource sharing)
    - 자원을 공유해서 효율성 증가 (커널의 개입을 피할 수 있음) → context switching이 발생하지 않음
    - 동일 address space에서 스레드가 여러 개 있다
- 경제성
    - 프로세스의 생성, context switch에 비해 효율적
- 멀티 프로세서(multi-processor) 활용
    - 병렬 처리를 통해 성능을 향상시킴

### 스레드 사용의 예

- 게임을 수행할때 화면 출력, 사용자 입력, 스피커/마이크 출력 등을 동시에 처리해야 된다. → 여러 스레드들을 활용
- 스레드 간에 게임에 대한 데이터 정보들은 공유한다.

# 2) 스레드의 구현

- 사용자 수준 스레도와 커널 수준 스레드로 구혀닝 가능하다

### 사용자 수준 스레드 (User Thread)

- **사용자의 영역의 스레드 라이브러리로 구현 됨**
    - 스레드의 생성, 스케줄링 등
    - POSIX threads, Win32 threads Java thread API 등
- **커널은 스레드의 존재를 모른다.**
    - 커널의 관리 (개입)을 받지 않는다.
        - 생성 및 관리의 부하가 적고 유연한 관리가 가능하다.
        - 이식성 (Portability)이 높음
    - 커널은 프로세스 단위로 자원을 할당한다.
        - 하나의 스레드가 block 상태가 되면, 모든 스레드가 대기한다.
        - (single-threaded kernel의 경우)
- 여러 개의 사용자 수준 스레드가 하나의 커널 수준 스레드에 일대다 mapping

### 커널 수준 스레드 (Kernel Threads)

- OS가 직접 스레드를 관리함.
- 커널 영역에서 스레드의 생성, 관리를 수행함
    - Context Switching 등 부하(Overhead)가 큼
    - 사용자 수준 스레드에 비해 무겁다
- 커널이 각 스레드를 개별적으로 관리함
    - 프로세스 내 스레드들이 병행 수행이 가능하다.
    - 하나의 스레드가 block 상태가 되어도, 다른 스레드는 계속 작업 수행이 가능하다.
- 하나의 사용자 수준 스레드가 하나의 커널 수준 스레드에 일대일 mapping

### 혼합형 스레드 모델

- n개 사용자 수준 스레드 - m개의 커널 스레드 (n>m)
    - 사용자는 원하는 수 만큼 스레드를 사용함.
    - 커널 스레드는 자신에게 할당된 하나의 사용자 스레드가 block 상태가 되어도, 다른 스레드 수행 가능
    - 병행 처리 가능
- 효율적이면서 유연함!
