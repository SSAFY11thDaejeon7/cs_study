## 프로세스와 스레드

![4일차-1](https://github.com/SSAFY11thDaejeon7/cs_study/assets/80624927/227d6f30-e54d-4840-8c27-348fdbb511de)

- 프로세스는 리소스를 받아 제어한다.
- 스레드는 위 과정에서 제어하는 부분을 의미한다.
- 하나의 프로세스 안에 여러개의 스레드가 존재할 수 있다.
- 프로세스가 할당받은 리소스를 같은 프로세스 내에 있는 스레드들은 공유할 수 있다.
<br>

## 스레드 (Thread)
- Light Weight Prcoess: **스레드는 자원을 공유하고 자신만의 제어 요소만 가지고 있으므로** 일반 프로세스보다 가볍다
- 프로세서(CPU) 활용의 기본 단위
- 구성 요소
  - Thread ID
  - Register set (PC 프로그램 카운터, SP 스택 포인터)
  - Stack (자신만의 작업 영역)
- 제어 요소 외 코드, 데이터 및 자원들은 프로세스 내 다른 스레드들과 공유
- 전통적 프로세스 = 단일 스레드 프로세스

싱글 스레드: 프로세스가 하나의 제어 요소를 가지고 있음
멀티 스레드: 프로세스가 여러개의 제어 요소를 가지고 있음
<br>

### 스레드의 장점
- 사용자 응답성
  - 일부 스레드의 처리가 지연되어도, 다른 스레드는 작업을 계속 처리 가능
- 자원 공유
   자원을 공유해서 효율성 증가 (커널의 개입을 피할 수 있음)
- 경제성
  - 프로세스의 생성, context switch에 비해 효율적
- 멀티 프로세서 활용
  - 병렬처리를 통해 성능 향상
<br>

## 사용자 수준 스레드 (User Thread)
- 사용자 영역의 스레드 라이브러리로 구현됨
  - 스레드의 생성, 스케줄링 등
- 커널은 스레드의 존재를 모름
  - 커널의 관리(개입)을 받지 않음
    - 생성 및 관리의 부하가 적음, 유연한 관리 가능
    - 이식성이 높음
  - 커널은 프로세스 단위로 자원 할당
    - 하나의 스레드가 block 상태가 되면, 모든 스레드가 대기 (싱글 스레드 커널의 경우)
  
![4일차-2](https://github.com/SSAFY11thDaejeon7/cs_study/assets/80624927/b3a58fc5-be03-4556-b520-a6300d582565)
<br>

## 커널 수준 스레드 (Kernel Threads)
- OS(Kernel)가 직접 관리
- 커널 영역에서 스레드 생성, 관리 수행 -> 단점
  - Context switching 등 부하(Overhead)가 큼
- 커널이 각 스레드를 개별적으로 관리
  - 프로세스 내 스레드들이 병행 수행 가능
    - 하나의 스레드가 block 상태가 되어도, 다른 스레드는 계속 작업 수행 가능

![4일차-3](https://github.com/SSAFY11thDaejeon7/cs_study/assets/80624927/b327d746-d168-44cc-a3bb-8f77558df52f)
<br>

## 혼합형 (n:m) 스레드
- n개 사용자 수준 스레드 - m개의 커널 스레드 (n > m)
  - 사용자는 원하는 수만큼 스레드 사용
  - 커널 스레드는 자신에게 할당된 하나의 사용자 스레드가 block 상태가 되어도, 다른 스레드 수행 가능
    - 병행 처리 가능
- 효율적이면서도 유연함

![4일차-4](https://github.com/SSAFY11thDaejeon7/cs_study/assets/80624927/3af89ecd-0d95-421a-a57f-064011aa954b)

